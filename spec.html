<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Atomics.waitAsync</title>
<pre class=metadata>
  title: Atomics.waitAsync
  status: proposal
  stage: 2
  location: https://github.com/tc39/proposal-atomics-wait-async
  copyright: false
  contributors: Lars Hansen, Shu-yu Guo
</pre>
<emu-intro id="intro">
  <h1>Atomics.waitAsync</h1>
  <p>We provide a new API, `Atomics.waitAsync`, that an agent can use to wait on a shared memory location (to later be awoken by some agent calling Atomics.notify on that location) without waiting synchronously (ie, without blocking). Notably this API is useful in agents whose [[CanBlock]] attribute is false, such as the main thread of a web browser document, but the API is not restricted to such agents.</p>
  <p>The API is promise-based. Very high performance is not a requirement, but good performance is desirable.</p>
</emu-intro>

<emu-clause id="sec-semantics">
  <h1>Semantics</h1>

  <emu-clause id="sec-hostresolveinagent" aoid="HostResolveInAgent">
    <h1>HostResolveInAgent ( _W_, _promiseCapability_, _resolution_)</h1>
    <p><ins>This is a new section.</ins></p>
    <p>HostResolveInAgent is an implementation-defined abstract operation that takes three arguments, an agent signifier _W_, a PromiseCapability Record _promiseCapability_, and a value _resolution_. The host's responsibility is to resolve the _promiseCapability_ in the agent signified by _W_ with _resolution_ in finite time. The host may delay resolving the _promiseCapability_ in _W_, e.g. for resource management reasons, but the promise must eventually be resolved.</p>
  </emu-clause>

  <emu-clause id="sec-getwaiterlist">
    <h1>GetWaiterList ( _block_, _i_ )</h1>
    <p>A <dfn>WaiterList</dfn> is a semantic object that contains an ordered List of Records of the agent signifier, promise capability (possibly *undefined*), and an alarm of the agent that is waiting on a location (_block_, _i_) in shared memory; _block_ is a Shared Data Block and _i_ a byte offset into the memory of _block_. This list is agent-independent and, like the current WaiterList semantic object, is shared by all agents in an agent cluster.</p>
    <p><ins>There can be multiple entries in a WaiterList with the same agent signifier.</ins></p>
    <p><ins>The WaiterList has an attached <dfn>alarm set</dfn>, a set of truthy values. This set is manipulated only when the agent manipulating it is in the critical section for the WaiterList.</p>
    <p>The agent cluster has a store of WaiterList objects; the store is indexed by (_block_, _i_). WaiterLists are agent-independent: a lookup in the store of WaiterLists by (_block_, _i_) will result in the same WaiterList object in any agent in the agent cluster.</p>
    <p>Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and notifying agents on the list, adding and removing alarms -- may only be performed by agents that have entered the WaiterList's critical section.</p>
    <emu-note>
      <p>Conceptually, agents that call either `Atomics.wait` or `Atomics.waitAsync` are appended to WaiterList. If the call was to `Atomics.wait` in an agent A, a record with an *undefined* promise capability is inserted to be immediately preceding the first element whose agent signifier is A. If the call was to `Atomics.waitAsync`, the pair of the result PromiseCapability Record and A (_capability_, A) is appended.</p>
      <p>This enables two design goals:</p>
      <ol>
        <li>Waiting agents are notified in FIFO order for fairness.</li>
        <li>Asynchronous waits in one agent are notified in FIFO order, while synchronous waits are notified before any asynchronous wait. This is because resolving the Promise result of a call to `Atomics.waitAsync` does no meaningful computation if the agent is in a blocking wait.</li>
      </ol>
    </emu-note>
    <p>The abstract operation GetWaiterList takes two arguments, a Shared Data Block _block_ and a nonnegative integer _i_. It performs the following steps:</p>
    <emu-alg>
      1. Assert: _block_ is a Shared Data Block.
      1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.
      1. Assert: _i_ is divisible by 4.
      1. Return the WaiterList that is referenced by the pair (_block_, _i_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-alarm-functions">
    <h1>Alarm Functions</h1>
    <p><ins>This is a new section.</ins></p>
    <p>An alarm function is an anonymous built-in function that has [[WaiterList]], [[Waiter]], [[Kind]], and [[Result]] internal slots.</p>
    <p>When an alarm function is called with no arguments, the following steps are taken:</p>
    <emu-alg>
      1. Let _F_ be the active function object.
      1. Assert: _F_ has a [[WaiterList]] internal slot whose value is a WaiterList.
      1. Assert: _F_ has a [[WaiterRecord]] internal slot whose value is a Record.
      1. Let _WL_ be _F_.[[WaiterList]].
      1. Let _waiterRecord_ be _F_.[[WaiterRecord]].
      1. Set _waiterRecord_.[[Result]] to `"timed-out"`.
      1. Perform EnterCriticalSection(_WL_).
      1. Perform RemoveWaiter(_WL_, _waiterRecord_).
      1. Perform NotifyWaiter(_WL_, _waiterRecord_).
      1. Perform LeaveCriticalSection(_WL_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-addwaiter" aoid="AddWaiter">
    <h1>AddWaiter ( _WL_, <del>_W_</del><ins>_waiterRecord_</ins> )</h1>
    <p>The abstract operation AddWaiter takes two arguments, a WaiterList _WL_ and <del>an agent signifier _W_</del><ins>a Record _waiterRecord_</ins>. It performs the following steps:</p>
    <emu-alg>
      1. Assert: The calling agent is in the critical section for _WL_.
      1. <del>Assert: _W_ is not on the list of waiters in any WaiterList.</del>
      1. <ins>Let _inserted_ be *false*.</ins>
      1. <ins>If _waiterRecord_.[[PromiseCapability]] is *undefined*, then</ins>
        1. <ins>Assert: There is no record in _WL_ whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]].</ins>
        1. <ins>For each element _wr_ in _WL_, do</ins>
          1. <ins>If _wr_.[[AgentSignifier]] is _waiterRecord_.[[AgentSignifier]], then</ins>
            1. <ins>Insert _waiterRecord_ to immediately precede _wr_.</ins>
            1. <ins>Set _inserted_ to *true*.</ins>
      1. <ins>If _inserted_ is *false*, then</ins>
        1. <ins>Append _waiterRecord_ as the last element of _WL_.</ins>
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-removewaiter" aoid="RemoveWaiter">
    <h1>RemoveWaiter ( _WL_, <del>_W_</del><ins>_waiterRecord_</ins> )</h1>
    <p>The abstract operation RemoveWaiter takes two arguments, a WaiterList _WL_ and <del>an agent signifier _W_</del><ins>a Record _waiterRecord_</ins>. It performs the following steps:</p>
    <emu-alg>
      1. Assert: The calling agent is in the critical section for _WL_.
      1. Assert: <del>_W_</del><ins>_waiterRecord</ins> is on the list of waiters in _WL_.
      1. Remove <del>_W_</del><ins>_waiterRecord</ins> from the list of waiters in _WL_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-suspend" aoid="Suspend">
    <p>Change this function not to take a _timeout_ argument. Timeouts are now handled in the caller. (Not intended as a normative change.)</p>
    <h1>Suspend ( _WL_, _W_<del>, _timeout_</del> )</h1>
    <p>The abstract operation Suspend takes <del>three</del><ins>two</ins> arguments, a WaiterList _WL_<del>,</del><ins>and</ins> an agent signifier _W_<del>, and a nonnegative, non-*NaN* Number _timeout_</del>. It performs the following steps:</p>
    <emu-alg>
      1. Assert: The calling agent is in the critical section for _WL_.
      1. Assert: _W_ is equal to AgentSignifier().
      1. Assert: <del>_W_ is on the list of waiters.</del><ins>There is a record</ins> in _WL_ <ins>whose [[AgentSignifier]] field is _W_ and whose [[PromiseCapability]] field is *undefined*.</ins>
      1. Assert: AgentCanSuspend() is *true*.
      1. Perform LeaveCriticalSection(_WL_) and suspend _W_<del> for up to _timeout_ milliseconds</del>, performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost.  _W_ can <del>notify either because the timeout expired or because it was</del><ins>be</ins> notified explicitly by another agent calling NotifyWaiter(_WL_, _waiterRecord_, ...), and not for any other reasons at all.
      1. Perform EnterCriticalSection(_WL_).
      1. <del>If _W_ was notified explicitly by another agent calling NotifyWaiter(_WL_, _W_), return *true*.</del>
      1. <del>Return *false*.</del>
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-notifywaiter" aoid="NotifyWaiter">
    <h1>NotifyWaiter ( _WL_, <del>_W_</del><ins>_waiterRecord_</ins> )</h1>
    <p>The abstract operation NotifyWaiter takes two arguments,
      a WaiterList _WL_ and <del>an agent signifier _W_</del><ins>a Record _waiterRecord_</ins>. It performs the following steps:</p>
    <emu-alg>
      1. Assert: The calling agent is in the critical section for _WL_.
      1. Assert: <del>_W_</del><ins>_waiterRecord_</ins> is on the list of waiters.
      1. <ins>Assert: _waiterRecord.[[Result]] is either the String `"ok"` or the String `"timed-out"`.</ins>
      1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
      1. Let _eventsRecord_ be the Agent Events Record in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
      1. Let _agentSynchronizesWith_ be _eventsRecord_.[[AgentSynchronizesWith]].
      1. Let _notifierEventList_ be _eventsRecord_.[[EventList]].
      1. Let _waiterEventList_ be the [[EventList]] field of the element in _execution_.[[EventsRecords]] whose [[AgentSignifier]] is _W_.
      1. Let _notifyEvent_ and _waitEvent_ be new Synchronize events.
      1. Append _notifyEvent_ to _notifierEventList_.
      1. Append _waitEvent_ to _waiterEventList_.
      1. Append (_notifyEvent_, _waitEvent_) to _agentSynchronizesWith_.
      1. <del>Notify the agent _W_.</del>
      1. <ins>If _waiterRecord_.[[Alarm]] is truthy, then</ins>
        1. <ins>Perform CancelAlarm(_WL_, _waiterRecord_.[[Alarm]]).</ins>
      1. <ins>If _waiterRecord_.[[PromiseCapability]] is *undefined*, then</ins>
        1. <ins>NOTE: An *undefined* promise capability denotes a blocking wait.</ins>
        1. <ins>Notify the agent _waiterRecord_.[[AgentSignifier]].</ins>
      1. <ins>Else,</ins>
        1. <ins>Perform HostResolveInAgent(_W_, _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]])</ins>
        1. <ins>NOTE: An agent must not access another agent's promise capability in any capacity beyond passing it to the host.</ins>
    </emu-alg>
    <emu-note>
      <p>The embedding may delay notifying <del>_W_</del><ins>the agent whose signifier is _waiter_.[[AgentSignifier]]</ins>, e.g. for resource management reasons, but <del>_W_</del><ins>that agent</ins> must eventually be notified in order to guarantee forward progress.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="sec-addalarm" aoid="AddAlarm">
    <h1>AddAlarm( _WL_, _alarmFn_, _timeout_ )</h1>
    <p><ins>This is a new abstract operation.</ins></p>
    <p>The abstract operation AddAlarm takes three arguments, a WaiterList _WL_, a thunk _alarmFn_, and a nonnegative finite number _timeout_. It performs the following steps:</p>
    <emu-alg>
      1. Assert: The calling agent is in the critical section for _WL_.
      1. Let _alarm_ be a truthy value that is not in _WL_'s alarm set.
      1. Add _alarm_ to _WL_'s alarm set.
      1. After _timeout_ milliseconds has passed, perform the following actions concurrently:
        1. Perform EnterCriticalSection(_WL_).
        1. If CancelAlarm(_WL_, _alarm_) is *true*, then
          1. Perform ! Call(_alarmFn_, *undefined*, &laquo; &raquo;).
        1. Perform LeaveCriticalSection(_WL_).
        1. NOTE: _alarmFn_ is now dead.
      1. Return _alarm_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-cancelalarm" aoid="CancelAlarm">
    <h1>CancelAlarm( _WL_, _alarm_ )</h1>
    <p><ins>This is a new abstraction operation.</ins></p>
    <p>The abstract operation CancelAlarm takes two arguments, a WaiterList _WL_, and a truthy value _alarm_. It performs the following steps:</p>
    <emu-alg>
      1. Assert: The calling agent is in the critical section for _WL_.
      1. Assert: _alarm_ is a truthy value.
      1. If _alarm_ is in _WL_'s alarm set, then
        1. Remove _alarm_ from _WL_'s alarm set.
        1. Return *true*.
        1. NOTE: No alarm that subsequently triggers for _alarm_ (in the concurrent thread referenced in AddAlarm) will have any effect. If not called from AddAlarm, the thunk associated with _alarm_ is now dead and can be reclaimed; any scheduled timeout associated with alarm can be canceled.
      1. Else return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-atomics.wait">
    <h1>Atomics.wait ( _typedArray_, _index_, _value_, _timeout_ )</h1>
    <p>`Atomics.wait` puts the calling agent in a wait queue and puts it to sleep until it is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg>
      1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
      1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
      1. Let _v_ be ? ToInt32(_value_).
      1. Let _q_ be ? ToNumber(_timeout_).
      1. If _q_ is *NaN*, let _t_ be *+&infin;*, else let _t_ be max(_q_, 0).
      1. Let _B_ be AgentCanSuspend().
      1. If _B_ is *false*, throw a *TypeError* exception.
      1. Let _block_ be _buffer_.[[ArrayBufferData]].
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
      1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
      1. Perform EnterCriticalSection(_WL_).
      1. Let _w_ be ! AtomicLoad(_typedArray_, _i_).
      1. If _v_ is not equal to _w_, then
        1. Perform LeaveCriticalSection(_WL_).
        1. Return the String `"not-equal"`.
      1. Let _W_ be AgentSignifier().
      1. <del>Perform AddWaiter(_WL_, _W_).</del>
      1. <del>Let _notified_ be Suspend(_WL_, _W_, _t_).</del>
      1. <del>If _notified_ is *true*, then</del>
        1. <del>Assert: _W_ is not on the list of waiters in _WL_.</del>
      1. <del>Else,</del>
        1. <del>Perform RemoveWaiter(_WL_, _W_).</del>
      1. <ins>Let _waiterRecord_ be a new Record { [[AgentSignifier]]: _W_, [[PromiseCapability]]: *undefined*, [[Alarm]]: *false*, [[Result]]: `"ok"` }.</ins>
      1. <ins>If _t_ is finite, then</ins>
        1. <ins>Let _stepsAlarm_ be the algorithm steps defined in Alarm Functions (<emu-xref href="#sec-alarm-functions"></emu-xref>).</ins>
        1. <ins>Let _alarmFn_ be CreateBuiltinFunction(_stepsAlarm_, &laquo; [[WaiterList]], [[WaiterRecord]] &raquo;).</ins>
        1. <ins>Set _alarmFn_.[[WaiterList]] to _WL_.</ins>
        1. <ins>Set _alarmFn_.[[WaiterRecord]] to _W_.</ins>
        1. <ins>Set _waiterRecord_.[[Alarm]] to AddAlarm(_WL_, _alarmFn_, _t_).</ins>
      1. <ins>Perform AddWaiter(_WL_, _waiterRecord_).</ins>
      1. <ins>Perform Suspend(_WL_, _W_).</ins>
      1. <ins>If _waiterRecord_.[[Result]] is `"ok"` and _waiterRecord_.[[Alarm]] is a truthy value, then</ins>
        1. <ins>Perform CancelAlarm(_WL_, _waiterRecord_.[[Alarm]]).</ins>
      1. Perform LeaveCriticalSection(_WL_).
      1. <del>If _notified_ is *true*, return the String `"ok"`.</del>
      1. Return <del>the String `"timed-out"`</del><ins>_waiterRecord_.[[Result]]</ins>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="atomics.waitasync">
    <h1>Atomics.waitAsync ( _typedArray_, _index_, _value_, _timeout_ )</h1>
    <p><ins>This is a new method.</ins></p>
    <p>`Atomics.waitAsync` returns a Promise that is resolved when the calling agent is notified or the sleep times out. The following steps are taken:</p>
    <emu-alg>
      1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
      1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
      1. Let _v_ be ? ToInt32(_value_).
      1. Let _q_ be ? ToNumber(_timeout_).
      1. If _q_ is *NaN*, let _t_ be *+&infin;*, else let _t_ be max(_q_, 0).
      1. Let _B_ be AgentCanSuspend().
      1. If _B_ is *false*, throw a *TypeError* exception.
      1. Let _block_ be _buffer_.[[ArrayBufferData]].
      1. Let _offset_ be _typedArray_.[[ByteOffset]].
      1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
      1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
      1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
      1. Perform EnterCriticalSection(_WL_).
      1. Let _w_ be ! AtomicLoad(_typedArray_, _i_).
      1. If _v_ is not equal to _w_, then
        1. Perform LeaveCriticalSection(_WL_).
        1. Perform ! Call(_capability_.[[Resolve]], *undefined*, &laquo; `"not-equal"` &raquo;).
        1. Return _promiseCapability_.[[Promise]].
      1. Let _W_ be AgentSignifier().
      1. Let _waiterRecord_ be a new Record { [[AgentSignifier]]: _W_, [[PromiseCapability]]: _promiseCapability_, [[Alarm]]: *false*, [[Result]]: `"ok"` }.</ins>
      1. Let _t_ is finite, then
        1. Let _stepsAlarm_ be the algorithm steps defined in Alarm Functions (<emu-xref href="#sec-alarm-functions"></emu-xref>).
        1. Let _alarmFn_ be CreateBuiltinFunction(_stepsAlarm_, &laquo; [[WaiterList]], [[WaiterRecord]] &raquo;).
        1. Set _alarmFn_.[[WaiterList]] to _WL_.
        1. Set _alarmFn_.[[WaiterRecord]] to _waiterRecord_.
        1. Set _waiterRecord_.[[Alarm]] to AddAlarm(_WL_, _alarmFn_, _t_).
      1. Perform AddWaiter(_WL_, _waiterRecord_).
      1. Perform LeaveCriticalSection(_WL_).
      1. Return _promiseCapability_.[[Promise]].
    </emu-alg>
  </emu-clause>

</emu-clause>
